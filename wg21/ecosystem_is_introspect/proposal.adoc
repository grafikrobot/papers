= Tool Introspection
:copyright: Copyright 2022 René Ferdinand Rivera Morell
:email: grafikrobot@gmail.com
:authors: René Ferdinand Rivera Morell, et al.
:audience: SG15
:revdate: {docdate}
:version-label!:
:reproducible:
:nofooter:
:sectanchors:
:sectnums:
:sectnumlevels: 5
:source-highlighter: rouge
:source-language: c++
:toc: left
:toclevels: 2
:caution-caption: ⚑
:important-caption: ‼
:note-caption: ℹ
:tip-caption: ☀
:warning-caption: ⚠
:table-caption: Table 

++++
<style>
.sectionbody > div > .ins {
  border-left: solid 0.4em green;
  padding-left: 1em;
  text-decoration: underline solid green;
  text-underline-offset: 0.3em;
}
.def > .content :first-child {
  margin-left: 0;
}
.def > .content > * {
  margin-left: 3em;
}
.icon .title {
  font-size: 250%;
}
</style>
++++

Document number: :: ISO/IEC/JTC1/SC22/WG21/{revnumber}
Date: :: {revdate}
Audience: :: {audience}
Reply-to: ::
René Ferdinand Rivera Morell - _grafikrobot at gmail dot com_

== Abstract

We propose to add a mechanism for {CPP} tools to communicate what capabilities
a tool implements from the Ecosystem IS.
footnote:EcoIS[https://wg21.link/P2656 {CPP} Ecosystem International Standard]

== Revision History

=== Revision 0 (November 2022)

Initial text.

== Motivation

{CPP} tools will implement the aspects of the Ecosystem IS footnote:EcoIS[] that
are relevant to the particular tool. And when they implement those aspects they
may implement ar particular edition of them. In order to allow other tools to
adjust their behavior to accommodate such differences we need a mechanism of
introspection for all tools. Additionally when one tool requests to use another
tool's Ecosystem IS aspect it's desirable to consistently communicate which
edition(s) of that aspect it can use.

== Design

There are two aspects that this proposal covers:

Introspection:: A tool reporting its capabilities to a consumer.

Declaration:: A consumer specifying the capability edition and version.

_Introspection_ would allow a consumer to ask the target tool if it implements a
particular set of capabilities. The target tool would respond with the range of
capabilities, or nothing, that it supports. With that information the consumer
can go ahead and follow the defined standard, in the Ecosystem IS
footnote:EcoIS[], to further interact with the target tool.

For _declaration_ a consumer can specify a particular capability and a version
to interact with. And if the target tool recognizes the specification it can
continue to process the consumer's use of that capability.

Even though these are two separate functions they are by necessity tied to each
other. In order for this pairing to work, and generally for tool
interoperability to work, the tool consumers and target tools must operate on
this minimal pair of functions to bootstrap their interactions. To make that
possible, this design follows some basic tenants:

[horizontal]

Minimal:: The interface of the target tool is a single universal command line
argument for each of the two operations.

Concise:: The information communicated to and from the targe tool and consumer
is as brief as needed to convey the required information.

Robust:: The interface and information should not result in failure conditions
for either the consumer or target tool. Both ends of the interactions need to
rely on the stability of the interface to then be able to interoperate.

=== Introspection

The consumer can use a single method to query the target tool and obtain all the
capabilities that are available or specifically requested. The following two
use cases are supported:

. Unbounded _introspection_ of the available capabilities with a single
valueless `--std-info` option.
. Bounded _introspection_ of particular capabilities with a single query valued
`--std-info=<query>` option.

==== Unbounded

An unbounded _introspection_ is the simplest form of obtaining the capabilities.
It is expected that this will be the most commonly used and implemented method
of obtaining this information. It simply returns everything the tool is capable
of doing. This is because it is the easiest to implement for tools. As it's
simply having a hard-wired result ready to output when needed. The drawback
though is that the consumer has more information to parse and compare to decide
how to interface with the target tool.

Running a `tool` with the option would look like the following:

[source,shell]
----
$ tool --std-info
----

And could produce this as a JSON output:

[source,json]
----
{
  "$schema": "https://raw.githubusercontent.com/cplusplus/ecosystem-is/release/schema/std_info-1.0.0.json",
  "std:info": "[1.0.0,2.5.0]"
}
----

Which would minimally indicate that the tool only supports the introspection
capability at version "1.0.0".

==== Bounded

A bounded _introspection_ makes it possible to specify particular capabilities
that a consumer is looking for in a target tool. By giving a query to the targe
tool the consumer cat get an answer for just the capability they care about.
This is particularly useful in cases where the consumer only support some
versions of a capability and prefers to not implement the version comparison
logic to determine this from the unbounded _introspection_.

The bounded _introspection_ works equivalent to the unbounded case except the
`--std-info` option takes a _specification_ value to say what capabilities to
filter the results by. For example running:

[source,shell]
----
tool "--std-info=std:info[1.0.0,2.1.0)"
----

And could produce this as a JSON output:

[source,json]
----
{
  "$schema": "https://raw.githubusercontent.com/cplusplus/ecosystem-is/release/schema/std_info-1.0.0.json",
  "std:info": "[1.5.0,2.0.0]"
}
----

Which means the tool is saying that tool only supports a subset of what the
consumer asked about.

=== Declaration

`--std-decl=<spec>`

=== Format

The information reported by _introspection_ is a JSON format
footnote:json[Bryan, P., Ed., Zyp, K., and Nottingham, M., Ed., "JavaScript Object Notation (JSON) Pointer", RFC 6901, DOI 10.17487/RFC6901, April 2013, http://www.rfc-editor.org/info/rfc6901]
document. Some advantages to using JSON:

* It is widely used and available either natively or through libraries in many
programming languages. Which is particularly important as {CPP} tools are
written in an array of differing programming languages.
* It is a simple format to understand by both programs and humans.

[source,json]
----
{
  "$schema": "https://raw.githubusercontent.com/cplusplus/ecosystem-is/release/schema/std_info-1.0.0.json",
  "std:info": "1.0.0"
}
----

[source,json]
----
{
  "$schema": "https://raw.githubusercontent.com/cplusplus/ecosystem-is/release/schema/std_info-1.0.0.json",
  "std:info": "[1.0.0,2.0.0)"
}
----

[source,json]
----
{
  "$schema": "https://raw.githubusercontent.com/cplusplus/ecosystem-is/release/schema/std_info-1.0.0.json",
  "std:info": "[1.0.0,2.0.0)",
  "gcc:extra": "1.5.0"
}
----

=== Impact On The Standard

== Implementation Experience

None yet.

== Polls

None yet.

== Wording

None yet.

== Acknowledgements

None yet.
