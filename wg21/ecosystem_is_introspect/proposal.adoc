= Tool Introspection
:copyright: Copyright 2022-2023 René Ferdinand Rivera Morell
:license: Creative Commons Attribution 4.0 International License (CC BY 4.0)
:email: grafikrobot@gmail.com
:authors: René Ferdinand Rivera Morell
:audience: SG15
:revdate: {docdate}
:version-label!:
:reproducible:
:nofooter:
:sectanchors:
:sectnums:
:sectnumlevels: 10
:source-highlighter: rouge
:source-language: c++
:toc: left
:toclevels: 2
:caution-caption: ⚑
:important-caption: ‼
:note-caption: ℹ
:tip-caption: ☀
:warning-caption: ⚠
:table-caption: Table

++++
<style>
include::../std-min.css[]
</style>
++++

[horizontal]
Document #: :: ISO/IEC/JTC1/SC22/WG21/{revnumber}
Date: :: {revdate}
Audience: :: {audience}
Authors: :: {authors}
Reply-to: :: {email}
Copyright: :: {copyright}, {license}

== Abstract

We propose to add a mechanism for {CPP} tools to communicate what capabilities
a tool implements from the Ecosystem IS.
footnote:EcoIS[{CPP} Ecosystem International Standard (https://wg21.link/P2656)]

== Revision History

[.chg]
=== Revision 3 (October 2023)

Added poll results from June 2023 WG21 meeting.

Adds the use of an "introspection file" as an alter way to provide the
introspection information for situations where it is not desirable or possible
to execute a program for the information.

Adds support for two option syntax styles to widen the set of applications that
can support implementing this specification without having them change their
option syntax parsing. The result is that we now support all major {CPP}
compilers and many more other ecosystem tools.

Adopt the semantic versioning specification to both define the syntax and
semantics of compatibility for capabilities.

=== Revision 2 (June 2023)

Changed wording to match text in draft IS. Use Unicode for literals as needed.
Changed the version numbers to follow the Semantic Versioning, and JSON, specs
of not allowed leading zeros. Add array of version ranges to full level support
to allow for disjoint support reporting. Updated the JSON schema to correct it
not properly excluding extra unknown properties, to correctly restrict the
syntax of capability names and values, and to add array of version ranges for
capability fields. Change capability names to allow for numbers. Add exposition
on command option handling and specification files. Add some possible user
interface alternatives for obtaining the specification JSON text. And describe
the currently preferred choice.

=== Revision 1 (May 2023)

Addition of scope, functionality levels, use cases, and wording.
Simplified introspection and declaration interfaces to make implementing
introspection trivial and declaration straightforward. The simplification
removes the _bounded_ introspection interface as superfluous.

=== Revision 0 (December 2022)

Initial text.

== Motivation

{CPP} tools will implement the aspects of the Ecosystem IS footnote:EcoIS[] that
are relevant to the particular tool. And when they implement those aspects they
may implement a particular edition of them. In order to allow other tools to
adjust their behavior to accommodate such differences we need a mechanism of
introspection for all tools. Additionally when one tool requests to use another
tool's Ecosystem IS aspect it's desirable to consistently communicate which
edition(s) of that aspect it can use.

== Scope

This proposal aims to specify a method for tools to communicate which specific
aspects of the Ecosystem IS they support and adhere to consumers (either other
tools or users). It does not prescribe which aspects of the Ecosystem IS the
tools must support or adhere to except to prescribe that supporting any
capability of the Ecosystem IS must also support this aspect. Ultimately it
wants to make it possible to address two cases:

* What does the tool support and adhere to?
* The tool should adhere to what the consumer asks if possible.

== Design

There are two aspects that this proposal covers:

Introspection:: A tool reporting its capabilities to a consumer.

Declaration:: A consumer specifying the capability edition and version.

_Introspection_ would allow a consumer to ask the target tool what versions of
of capabilities it supports. The target tool would respond with the range of
capabilities, or nothing, that it supports. With that information the consumer
can go ahead and follow the defined standard, in the Ecosystem IS
footnote:EcoIS[], to further interact with the target tool.

For _declaration_ a consumer can specify a particular capability and a version
to interact with. And if the target tool recognizes the specification it can
continue to process the consumer's use of that capability.

Even though these are two separate functions they are by necessity tied to each
other. In order for this pairing to work, and generally for tool
interoperability to work, the tool consumers and target tools must operate on
this minimal pair of functions to bootstrap their interactions. To make that
possible, this design follows some basic tenets:

[horizontal]

Minimal:: The interface of the target tool is a single universal command line
argument for each of the two operations.

Concise:: The information communicated to and from the target tool and consumer
is as brief as needed to convey the required information.

Robust:: The interface and information should not result in failure conditions
for either the consumer or target tool. Both ends of the interactions need to
rely on the stability of the interface to then be able to interoperate.

=== Introspection

NOTE: We used to include a _bounded_ introspection option. But turned out to be
not worth the added complexity in the consumer and tool.

The consumer can use a single method to query the target tool and obtain all the
capabilities that are available or specifically requested. The use case
supported is for unbounded _introspection_ of the available capabilities with a
single valueless `--std-info` option.

And unbounded introspection simply returns everything the tool is capable
of doing. The tool has the option to respond with either all minimal single
(aka bare) versions or full version ranges. Either can be trivially implemented
by tools as most time it can be a hard-wired response text.

Running a tool with the option would look like the following:

[source,shell]
----
$ tool --std-info
----

And could produce this as a minimal JSON output to indicate the single version
of the capabilities it supports:

[source,json]
----
include::example-01.json[]
----

Or could produce this as a JSON output in the case of full version ranges:

[source,json]
----
include::example-02.json[]
----

Which would minimally indicate that the tool only supports the introspection
capability at versions "1.0.0" through "2.5.0".

[.chg]
--

Per the findings of the <<User Interface>> research and the consensus of the
<<SG15: P2717R2 (2023-06-16)>> polling a tool can, additionally, provide the
introspection information in a file accompanying the tool. There is a challenge
when providing such an introspection file though: It is not practical to specify
an absolute location, or locations, across the variety of operating systems and
tools in the {CPP} ecosystem. As such we provide some possibilities:

1. The name of an introspection file will be the name of the top level invoked
tool executable (or script, or equivalent) with any type extension
(i.e. "`.exe`") removed if it exists. That base name will be appended with the
`.stdinfo` text. For example: `cl.exe` => `cl.stdinfo`, or
`pass:[g++]` => `pass:[g++].stdinfo`.

2. The introspection file can be found: in the same filesystem location
as the tool executable (or script, or equivalent), in an implementation defined
location relative to the tool location, or in an implementation defined global
location (i.e. an absolute path location).

NOTE: The choice of the `.stdinfo` extension is subject to a naming discussion.

--

=== Declaration

The consumer can inform, i.e. declare, to the target tool that specific
capabilities should use particular versions when responding with information
using one or more `--std-info=<VersionSpec>` options. The declarations can only
exist in tandem with options for the mentioned capabilities. It's expected that
a consumer will first _introspect_ a target tool to discover what it supports.
Followed by the consumer _declaring_ to the target tool what version(s) of the
capabilities it is willing to consume. The target tool can then either accept
the declared capability versions or indicate an error.

An exchange between a consumer and target tool would begin with the
_introspection_:

[source,shell]
----
tool "--std-info"
----

With a target tool response:

[source,json]
----
include::example-03.json[]
----

Which the consumer can use to _declare_ the specific capability versions:

[source,shell]
----
tool "--std-decl=std:info=2.0.0" "--std-decl=gcc:extra=2.1.0" ...
----

=== Levels

For some use cases it helps to simplify the extent of information the
introspection understands. While it would be reasonable to expect a tool written
in a modern general purpose programming language to fully implement all aspects
of the introspection. It would not be practical to have a shell script parse
and recognize the more challenging aspect of parsing version number ranges and
matching them together. To support such use cases the introspection has to
support levels "min" and "full".

Obviously the "full" level equates to the tool understanding all the arguments
and values. The "min" level only understands these:

* Only introspection `--std-info` option.
* Single version number in the responses for `--std-info`.

This has the effect that a tool which only support the "min" level can only
support specific versions of the capabilities it implements. But it also means
that consumers will need to adjust their behavior to the tool instead of being
able to ask the tool to adjust to the consumer. Consequently the consumer will
likely have the more complex logic to do that adjustment.

=== Capabilities

For this proposal capabilities refers to any published coherent target tool
interface. This can include any single interface, like a single target tool
option. Or it can include a collective interface of the target tool that covers
many options. A capability is specified as a series of "scoped" identifiers
separated by colons (":"). The capability must match this regular expression:
footnote:Regex[ECMAScript® 2022 language specification, 13th edition, June 2022 (https://www.ecma-international.org/publications-and-standards/standards/ecma-262/)]

[source,plan_text]
----
^[a-z0-9_]+(:[a-z0-9_]+)+$
----

At minimum a capability has two components. The first component is a general
scope that identifies if the capability is one in the IS, or if it's a tool
vendor capability.

Standard:: A capability with a scope of `std` indicates that it's defined in the
IS. footnote:EcoIS[]

Vendor:: Any other capability, i.e. other than `std`, is available for vendors
to use as extensions outside the IS. footnote:EcoIS[]

There was a question on "Why not alow 0-9 in the name?". Considering this brings
up the question as to the utility of having numbers in the name. An
obvious use case is to add versioning to the name, for example `std2`. That is a
case we want to avoid. As it avoids using the version numbers themselves which
subverts the spirit of the introspection. Another use case is to cover vendor
specific names for tools that use a number in their names, for example `b2`,
`build2`. Because that is a currently existing use case, and that forcing such
applications that want custom capabilities to create alternate names has
various drawbacks, yes, we should accept numbers in the names.

=== Version Specification

When indicating the version, or versions, to the target tool or the consumer the
version information is specified in two possible forms: a single version, or a
single version range.

[.chg]
==== Semantic Versioning

We use the base (pre-release and build labels are not allowed) specification of
Semantic Versioning 2.0.0
footnote:SemVer[Semantic Versioning 2.0.0 (https://semver.org/spec/v2.0.0.html)]
to define the syntax and semantics of compatibility.

==== Single Version

[.chg]
A single version in this proposal is composed of a one to three dotted whole
numbers. The numbers are expected to be strictly increasing.
Following SemVer footnote:SemVer[] a change to the MAJOR version indicates a
backward incompatible change. And changes to the MINOR and PATCH versions
indicate backward compatible changes.
The format for the version must match the regular expression: footnote:Regex[]

[source,plain_text]
----
^[0-9]+([.][0-9]+){0,2}$
----

==== Version Range

A version range in this proposal indicates a lower and upper bound of versions.
It is composed of a pair of versions, separated by a comma, and bracketed by
either an inclusive or exclusive symbol. This matches the intuition of a
mathematic interval, but with the use of the version triplet number line.
footnote:[Wikipedia: Interval (mathematics) (https://en.wikipedia.org/wiki/Interval_(mathematics))]
Like the interval notation the `()` brackets indicate an exclusive point. And
the `[]` brackets indicate an inclusive point. As versions are decidedly not
single integers we use a `,` (comma) to separate the start and end of the range
instead of using `..`. Hence the format for the version range must match the
regular expression:
footnote:Regex[]

[source,plain_text]
----
^[[(][0-9]+([.][0-9]+){0,2},[0-9]+([.][0-9]+){0,2}[)\\]]$
----

==== Multiple Ranges

There are situations where specifying only one version range for what the
application supports is not sufficient. For example an application may decide
that they add support for a `2.0.0` version but not support further `1.x.y`
versions. In that case it's important to be precise in informing consumers of
this fact. To allow for that situation one can specify a JSON array instead of
the single JSON string for the version range. For example:

[source,plain_text]
----
include::example-07.json[]
----

Would indicate support for versions 1.0.z through 1.2.0, and version 2.0.0.

=== Version Matching

When given two version specifications tools will need to match the two to
determine the sub-range that are compatible with both. There are two aspects to
doing that matching: comparing the two single versions, and evaluating the
sub-range interval.

==== Single Version Comparison

Comparing two single versions equates to three-way comparing each of the
components of both, `a` and `b`, as:

. If the whole numbers of the first components, `i` and `j`, are not equal the
comparison is either `a < b` or `a > b` if `i < j` or `i > j` respectively.
Otherwise,
. If the whole numbers of the second components, `k` and `l`, are not equal the
comparison is either `a < b` or `a > b` if `k < l` or `k > l` respectively.
Otherwise,
. If the whole numbers of the third components, `m` and `n`, are not equal the
comparison is either `a < b` or `a > b` if `m < n` or `m > n` respectively.
Otherwise,
. The versions are equal, i.e. `a == b`.

==== Range Comparison

Tools will need to compare either a single version to a version range, or a
version range to another range to determine the overlapping version sub-range.
The single version to a version range comparison can be reformulated to a
range-to-range comparison. I.e. a comparison of a single range `a` to a range
`b` is equivalent to a comparison of range `[a,a]` to range `b`. Hence we only
need to consider the range-to-range comparison. Although implementations may
use special case for comparing single-to-range and range-to-single.
Range-to-range should follow something like the following to compare a range
`a,b` to `m,n`, with some varied inclusive or exclusive ends:

. If `b < m` or `n < a` the range is _empty_.
. Otherwise, assign a _partial_ range `x,y = max(a,m), min(b,n)`.
. If `a` or `m` are inclusive, then:
.. If `b` or `n` are inclusive, then the range is `[x,y]`.
.. Otherwise, the range is `[x,y)`.
. Otherwise, if `b` or `n` are inclusive, then the range is `(x,y]`.
. Otherwise, the range is `(x,y)`.

=== Format

The information reported by _introspection_ is a JSON
footnote:json[ISO/IEC 21778:2017 Information technology — The JSON data interchange syntax, (https://www.iso.org/standard/71616.html)]
format document. Some advantages to using JSON:

* It is widely used and available either natively or through libraries in many
programming languages. Which is particularly important as {CPP} tools are
written in an array of differing programming languages.
* It is a simple format to understand by both programs and humans.

In maintaining our goals of the interface being minimal, concise, and robust,
the format for communicating the capabilities is a single key/value collection,
i.e. a JSON object.
footnote:json[]

Capability Identifier:: The _key_ is a string with the capability identifier. The
format of the is as described in the <<Capabilities>> section.

Version Specification:: The _value_ indicates the versions supported by the tool
for the capability. The versions follows the format described in the
<<Version Specification>> section.

In addition to the _capability identifier_ / _version specification_ members,
there are additional special members:

Schema:: The document can also specify a reference to a JSON Schema.
footnote:jschema[JSON Schema: A Media Type for Describing JSON Documents (http://json-schema.org/latest/json-schema-core.html)]
For this the _key_ would be `$schema`, and the _value_ would a URI to a
published stable schema
(`https://raw.githubusercontent.com/cplusplus/ecosystem-is/release/schema/std_info-1.0.0.json`).

There is one designated capability that is required to appear in the document:
The `std:info` capability with a corresponding _version specification_. This
requirement allows a consumer to identify the format of the rest of the document
at all times.

This is a minimal conforming document:

[source,json]
----
include::example-04.json[]
----

This is also a minimal conforming document. But specifies a range of versions
supported for the `std:info` capability:

[source,json]
----
include::example-05.json[]
----

This example adds a custom vendor capability and the schema reference:

[source,json]
----
include::example-06.json[]
----

See the <<Wording>> for a <<JSON Schema>> for this format.

=== Capability Versions

The capabilities and their version is expected to work similar to how {CPP}
feature macro version ([version.syn]) in that it specifies if a feature of a
standard is implemented and at what version. Although the meaning of the
capability version is not defined, it's recommended that it follow some simple
rules:

* The _major-number_ should only change for large changes.
* The _minor-number_ should only change for fixes that are significant, but not
  large.
* The _patch-number_ should only change for fixes that are simple and small.

[.chg]
That is, it follows the industry understanding of sematic versioning.
footnote:SemVer[]

* Each part of the version number should always increment, but;
* The _minor-number_ should reset to zero when the _major-number_ increases,
  equivalently for the _patch-number_ and _minor-number_.

These rules set it apart from the {CPP} feature macros that they impart some
meaning to a version relative to other versions.

=== User Interface

This proposal currently suggests to add some application command line (CLI)
options as the user interface for obtaining the introspection information. In
particular adding `--std-info=X` and `--std-info-out=X` options for any
conforming tool. Some compiler vendors expressed some concerns regarding this
choice:

* Launching the application to get this information can be expensive,
  particularly in "performance sensitive scenarios".
* It increases the binary size of applications. Which can impact deployment
  time in some environments, like continuous integration.

One alternative to adding command line options, in this case, and as suggested,
is to have an external fixed file with the content. This alternative hinges on
being able to find that file through some reasonably stable method.

We explore the pros and cons of both choices herein. Note, as this feature has
not yet been implemented the analysis below is an informed best guess.

First some assumptions:

. We are only going to consider the logic for adding the minimal conforming
  interface and introspection information result. I.e. _minimum level_
  (<<intspct-min>>) functionality.
. We will make some best effort prospective optimizations to an expected
  implementation. I.e. try to think of minimal code and data that reuses
  existing functionality in an application.

It is important to understand in these implementation considerations that tools
can be both an _application_ and _consumer_ in this. Where an _application_
is a tool producing the introspection information. And a _consumer_ ingests
that information. But either can be a compiler driver, linker, assembler,
analyzer, build system, package manager, IDE, and so on. For example a package
manager will invoke a build system for introspection. But also a build system
will invoke a package manager for introspection.

==== Command Line Options

Adding command line options to an application is a well know practice that has
a long history. As such it's relatively easy to estimate it's impact.

_(A) Application: Sizeof of introspection string in the application "binary"._

The absolute _minimum level_ conforming introspection string in this would be
`{"std:info":"1"}`. But that's not particularly useful as we would expect
some other items represented. Being generous we can make a guess of having 10
items:
`{"std:info":"1","std:first":"1","std:second":"1","std:third":"1","std:fourth":"1","std:fifth":"1","std:sixth":"1","std:seventh":"1","std:eighth":"1","std:ninth":"1"}`.
Which gives a total of 165 UTF-8 code points, or the same byte count, plus a
null terminator. We can round that up to 200 bytes total.

_(B) Application: Additional code to handle the options._

This cost is harder to estimate as the collection of application implementations
is varied in both method and programming languages. For this we can roughly
estimate an implementation difficulty for some of the most used tools in the
{CPP} ecosystem. Below is a survey of the difficulty of adding various command
line option syntax in three categories, compiler drivers, build systems, and
package managers:

[cols="1,1,1,1,1,1",options="header"]
|===
^|Tool
^|Current
^|`*--opt=val*`
^|`*-opt=val*`
^|`*--opt:val*`
^|`*-opt:val*`

6+^h|Compiler Driver

|`cl.exe` (Windows, macOS)
l|
/opt:val
-opt:val
3+^.^|_unknown_^1^
^.^|&check;

|`clang` (many)
l|
-opt val
-opt=val
--opt=val
^.^|&check;
^.^|&check;
2+^.^|Easy; use Joined<["--"], "foo:"> in `clang&#x200B;/&#x200B;include&#x200B;/&#x200B;clang&#x200B;/&#x200B;Driver&#x200B;/&#x200B;Options.td`.&nbsp;^2^

|`gcc` (many)
l|
-opt val
-opt=val
--opt=val
^.^|&check;
^.^|&check;
2+^.^|Trivial; just use `:` instead of `=` to spell the option in `*.opt`.&nbsp;^3^

6+^h|Build System

|Cmake (many)
l|
-opt val
-opt=val
--opt val
--opt=val
^.^|&check;
^.^|&check;
2+^.^|Easy; Add test for ':' in https://github.com/Kitware/CMake/blob/master/Source/cmCommandLineArgument.h#L102[`cm&#x200B;Command&#x200B;Line&#x200B;Argument.h`].&nbsp;^4^

|MSBuild (many)
l|
/opt:val
-opt:val
3+^.^|_unknown_^1^
^.^|&check;

|Ninja (many)
l|
-opt val
--opt=val
^.^|&check;
3+^.^|Very Hard; requires changing `getopt_long`.&nbsp;^5^

|QMake (many)
l|
-opt val
4+^.^|Medium; https://github.com/qt/qtbase/blob/55aee8697512af105dfefabc1e2ec41d4df1e45e/qmake/option.cpp#L173[it's custom {CPP}] ^6^

|GNU Make (many)
l|
-opt val
--opt=val
^.^|&check;
3+^.^|Very Hard; requires changing `getopt_long`.&nbsp;^5^

|autotools (Unix-like)
l|
-opt val
4+^.^|Very Hard

|Gradle (Java)
l|
-opt val
-opt=val
--opt val
--opt=val
^.^|&check;
^.^|&check;
2+^.^|Easy; it's a single custom parser: https://github.com/gradle/gradle/blob/master/subprojects/cli/src/main/java/org/gradle/cli/CommandLineParser.java[CommandLineParser.java] ^7^

|Bazel (Unix, macOS, Windows)
l|
--opt=val
--opt val
-opt val
^.^|&check;
3+^.^|Very Hard; Mostly Starlark code.

|nmake (Windows)
l|
/opt val
-opt val
4+^.^|Easy; it's a simple C arg parser.

|Meson (Python)
l|
-opt=val
--opt=val
--opt val
^.^|&check;
^.^|&check;
2+^.^|Hard; uses Python `argparse`.&nbsp;^8^

|SCons (Python)
l|
-o val
--opt=val
--opt val
^.^|&check;
^.^|&check;
2+^.^|Hard; uses Python `argparse`.&nbsp;^8^

|B2 (Boost Build)
l|
-oval
-o val
--opt=val
--opt val
^.^|&check;
^.^|Medium; custom C code, conflicts with `-oval`.
^.^|Easy; uses Jam+regex matching.
^.^|Medium; custom C code, conflicts with `-oval`.

6+^h|Package Manager

|Conan (Python)
l|
-opt=val
--opt=val
--opt val
^.^|&check;
^.^|&check;
2+^.^|Hard; uses Python `argparse`.&nbsp;^8^

|vcpkg (Many)
l|
--opt=val
^.^|&check;
3+^.^|Medium; custom C++ code.

|NuGet (Many)
l|
-opt val
4+^.^|_unknown_^1^

|Hunter (CMake)
l|
-Dopt=val
4+^.^|Impossible; it's written in CMake.

|Spack (Unix, macOS)
l|
-opt val
--opt val
2+^.^|Easy; may already be supported from use of Python `argparse`.
2+^.^|Hard; uses Python `argparse`.&nbsp;^8^

|Build2 (Many)
l|
-opt val
--opt val
4+^.^|Hard; Seems to use a custom language and compiler for argument definition
and parsing.

|===

1. Unable to estimate as it's closed source.
2. llvm-project has a few utilities that uses LLVMOption to parse command line
options. See `fdOpts.td`.
3. Would prefer not to depart from existing POSIX conventions.
4. https://github.com/Kitware/CMake/blob/master/Source/cmCommandLineArgument.h#L102
5. Uses `gnuopt_long` in `gnulib/lib/getopt.c`. Which has a global effect on
the ecosystem of tools that use `getop_long` across many systems.
6. https://github.com/qt/qtbase/blob/55aee8697512af105dfefabc1e2ec41d4df1e45e/qmake/option.cpp#L173
7. https://github.com/gradle/gradle/blob/master/subprojects/cli/src/main/java/org/gradle/cli/CommandLineParser.java
8. Choosing to change the Python `argparse` as a solution for this results in a
global effect on all Python programs that use `argparse` and would prevent
backward compatibility.

Of the above set of possible option syntaxes and within the set of applications
the most widely accepted option syntax is the `--opt=val` variation. Hence, it
currently appears, that the least cost avenue is to use the `--opt=val` syntax
globally for the Ecosystem IS.

Although the cost of using `--opt=val` varies across the range of applications
in aggregate we can estimate the cost as "medium". As most applications already
support this option syntax. And it's possible for some other applications to add
limited support for this syntax.

_(+C+) Consumer: Executing the application._

The cost of executing the an application comes in different parts:

1. There's the basic cost of the execution itself, which varies between
environments. But is a well known cost and easy to account for.
2. There's the cost of, at best, one more execution of the application to gather
the introspection information.

==== Specification File

Having an additional specification file can support some additional use cases
that using command line options can't. The idea for this alternative is to have
the JSON information in a file that is easily findable by consumers. Some
possible locations are: as a specially named sibling to the application, in some
standard location in the system with a special file name, manually specified
by the user (for example through an environment variable or other consumer
specific configuration). There are a couple of differing costs involved in
having introspection files:

_(A) Application: Deployment of extra file with application "binary"._

Most applications already deploy extra files that support the main application.
Hence adding another file is of negligible cost. Where the file is located is
a concern. As finding a single consistent location for such a file across many
environments is very difficult, at best, or impossible at worse. For example,
while it's natural to have a sibling to the executable information file on
Windows, it's not usual on Unix when installing to the system directories
(i.e. `/bin`).

An aspect of having the extra file is both the extra on-disk storage and
time to install the file. For many uses this is not a concern. But there are
classes of cases where the install is done repeatedly as would be seen in CI
testing systems that require fresh installs. This is a concern regardless of
where the data lives though. As it's the same data if it's an extra file or
embedded in the application.

_(B) Consumer: Deployment of extra file with application "binary"._

A common method of distributing computation, especially {CPP} compiles, is to
transport the tools from one machine to many, for example Incredibuild. The
cost of transporting this extra file is minimal though. As the data is small,
as shown above, and such systems are already dealing with transporting and
caching such information.

_(+C+) Consumer: Additional code to find the application "binary"._

If the extra file is available from some location relative to the application
consumers will need to implement search methods to first find the application
before attempting to find the extra file. This search can be challenging for a
variety of reasons like: needing to interpret `PATH` searching (in the case of
not having an absolute file path), accounting for following symbolic links (or
equivalents), avoiding user permission restrictions, and so on. The difficulty
of this will also differ based on the utilities available in the language the
application is written in and what the system provides.

_(D) Consumer: Additional code to find the introspection file._

Assuming we have a path to the application, per above, and/or that we have known
locations it is relatively straightforward to find a specially named extra file.
But that the more choices one has to account for the more implementation there
is that can run into problems. Additionally tools like Incredibuild would need
to learn about the extra file and consumers might need to use special logic to
account for both the usual location of the file and the transported file
location.

==== Alternatives

Given all that we can try and evaluate some alternative user user interface
possibilities. Note, that these are not exhaustive. But they are, currently,
the most likely to work in the widest set of use cases.

[cols="^1,1a,1a",options="header"]
|===

^|
^| Pros
^| Cons

|*Single Option Style* +
`--std-info=X`, `--std-info-file=X`
|
* Low implementation cost.
* Uniform handling for consumers.
|
* Some applications will need to implement a new option style.
* Running the application may not be possible by the consumer.

|*Two Option Styles* +
`--std-info=X`, `--std-info-file=X` and/or `-std-info:X`, `-std-info-file:X`
|
* Low implementation cost.
* Limited set of option handling for consumers.
* Avoids changing Microsoft tools option handling.
|
* Adds an extra check, and context, for consumers.
* Running the application may not be possible by the consumer.

|*Implementation Defined Option Style* +
(i.e. current status quo)
|
* Low implementation cost.
* No changes to option handling for producers.
|
* Adds extra checks, and contexts, for consumers.
* Running the application may not be possible by the consumer.

|*Specification File*
|
* Avoids cost of adding options for producers.
* Allows use when the application can't be executed.
|
* Adds complexity of finding the file for consumers.
* Adds cost of transporting file along with the application where needed.

|*Specification File and "Two Option Styles"*
|
* Low implementation cost.
* Limited set of option handling for consumers.
* Avoids changing Microsoft tools option handling.
* Allows use when the application can't be executed.
|
* Some applications will need to implement a new option style.

|===

As we can see, no alternative is a perfect choice. But hopefully we can see that
the last one, _Specification File and "Two Option Styles"_ is the most
advantageous. But what is it? Other than the obvious of mashing the
_Specification File_ and _"Two Option Style"_ alternatives together. The
characteristics and requirements would be:

1. A producer would be required to implement one or both of the two option
styles: `--opt=val` or `-opt:val`.
2. A producer would be required to indicate an error for an option style it does
not accept.
3. A producer could implement the `std-info-file` request as they wish, including
reading from a file, reading from internal fixed text, dynamically generating
the information, or any other method it deems appropriate.
4. A consumer that wants to execute the producer directly would be required
to try both the `--opt=val` and `-opt:val` styles in an order of its choosing
to find the style that works for the producer.
5. A consumer can save the produced information, using the `std-info-file`
option, or other method of its choosing to a file that it can read directly
afterwards.
6. A consumer that does not want to execute the producer directly can use a
previously saved information file.
7. A consumer that does not want to execute the producer directly is required to
search a small, defined, set of either relative to the producer or absolute
locations for a specified specially named file.

The key differences from the previous specification of only the _Single Option
Style_ alternative are:

* The addition of the `-opt:val` style.
* Item (4) on consumers to try both option styles.
* Item (7) specifying some search location for the information file.

That combination of features and requirements avoids most of the problems one
can encounter without creating additional ones.

=== Impact On The Standard

This specification adds new functionality that is partly required for programs.
Other specifications that define program behavior will need to follow this
specification for conformance to the Ecosystem IS.

== Implementation Experience

None yet.

== Polls

=== SG15: P2717R0 (2023-01-27)

SG15 wants to pursue defining in the Tooling IS a way for tools to provide
portable information about which parts of the Tooling IS and vendor extensions
they support.

[options="header,autowidth",cols="^0,^0,^0,^0,^0"]
|===
| SF | F | N | A | SA
| 5  | 3 | 0 | 0 | 0
|===

[.chg]
=== SG15: P2717R2 (2023-06-16)

Require a specification file and a procedure how it is found.

[options="header,autowidth",cols="^0,^0,^0,^0,^0"]
|===
| SF | F | N | A | SA
| 1  | 6 | 4 | 1 | 0
|===

Result: Consensus

Require tools to support at least one of the two styles of
command line options (if the tool can be run at all).

[options="header,autowidth",cols="^0,^0,^0,^0,^0"]
|===
| SF | F | N | A | SA
| 4  | 5 | 1 | 2 | 0
|===

Result: Consensus

The capabilities documented by the IS should be versioned
in a way that supports backwards incompatible changes.

[options="header,autowidth",cols="^0,^0,^0,^0,^0"]
|===
| SF | F | N | A | SA
| 4  | 6 | 1 | 0 | 0
|===

Result: Consensus

== Wording

Wording is relative to
link:https://github.com/cplusplus/ecosystem-is/tree/5c7ecf79235488bb9aa05505cbfe01ff2b9281e0[ecosystem-is/5c7ecf7].
footnote:[Working Draft, {CPP} Ecosystem International Standard 2023-04-01 (https://github.com/cplusplus/ecosystem-is/tree/5c7ecf79235488bb9aa05505cbfe01ff2b9281e0)]

=== Normative references

In [intro.refs] add:

[.ins.text-justify]
POSIX::
ISO/IEC 9945:2009, _Information technology — Portable Operating System Interface (POSIX®) Base Specifications, Issue 7_
JSON::
ISO/IEC 21778:2017, _Information technology — The JSON data interchange syntax_
Mathematics::
ISO 80000-2:2019, _Quantities and units — Part 2: Mathematics_

[.chg]
[.ins.text-justify]
SemVer::
The SemVer Team. Semantic Versioning 2.0.0. June 18 2013.
Available at: https://semver.org/spec/v2.0.0.html

=== Specification: Conformance

Insert clause before _Terms and definitions_ [intro.defs].

[.ins.text-justify]
[#cnf,reftext=cnf]
==== Conformance [.right]#[<<cnf>>]#

A conforming implementation shall meet the following criteria for conformance to
this standard:

— An application shall support the _minimum level_ functionality of
introspection (<<intspct-min>>).

=== Definitions

Add the following to _Terms and definitions_ [intro.defs].

[.ins.text-justify]
[#defns-application,reftext=defns.application]
==== application [.right]#[<<defns-application>>]#

a computer program that performs some desired function.

_NOTE 1_: From POSIX.

[.ins.text-justify]
[#defns-capability,reftext=defns.capability]
==== capability [.right]#[<<defns-capability>>]#

an aspect of an overall specification that defines a subset of the entire
specification.

[.chg]
[.ins.text-justify]
[#defns-directory,reftext=defns.directory]
==== directory [.right]#[<<defns-directory>>]#

a file that contains directory entries.

_NOTE 1_: From POSIX.

[.chg]
[.ins.text-justify]
[#defns-direntry,reftext=defns.direntry]
==== directory entry [.right]#[<<defns-direntry>>]#

an object that associates a filename with a file.

_NOTE 1_: From POSIX.

[.ins.text-justify]
[#defns-file,reftext=defns.file]
==== file [.right]#[<<defns-file>>]#

an object that can be written to, or read from, or both.

_NOTE 1_: From POSIX.

[.chg]
[.ins.text-justify]
[#defns-filename,reftext=defns.filename]
==== filename [.right]#[<<defns-filename>>]#

a sequence of bytes used to name a file.

_NOTE 1_: From POSIX.

[.chg]
[.ins.text-justify]
[#defns-parentdir,reftext=defns.parentdir]
==== parent directory [.right]#[<<defns-parentdir>>]#

a directory containing a directory entry for the file under discussion.

_NOTE 1_: From POSIX.

[.chg]
[.ins.text-justify]
[#defns-pathname,reftext=defns.pathname]
==== pathname [.right]#[<<defns-pathname>>]#

a string that is used to identify a file.

_NOTE 1_: From POSIX.

=== Specification: Introspection

Insert clause after _Terms and definitions_ [intro.defs].

[.ins.text-justify]
[#intspct,reftext=intspct]
==== Introspection [.right]#[<<intspct>>]#

[#intspct-pre,reftext=intspct.pre]
===== Preamble [.right]#[<<intspct-pre>>]#

This clause describes options, output, and formats that describe what
capabilities of this standard an application supports. An application shall
support the _minimum level_ functionality (<<intspct-min>>). An application can
support the _full level_ functionality (<<intspct-full>>).

This clause specifies the `std:info` capability (<<intspct-cap>>).

[#intspct-overview,reftext=intspct.overview]
===== Overview [.right]#[<<intspct-overview>>]#

[.chg]
--
`_application_ [ __std-info-opt__ [__declaration__] ] [ __std-info-out-opt__ __file__ ]`
--

[#intspct-options,reftext=intspct.options]
===== Options [.right]#[<<intspct-options>>]#

[.chg]
Applications shall accept one of two options syntax variations:
`--name=value` (`--name` without a value) or `-name:value` (`-name` without a
value).

[.chg]
Applications shall indicate an error if invoked with an option syntax variation
that it does not support.

[.chg]
_NOTE 1_:
An application will report the error in what is conventional for the platform
it runs in. On POSIX and Windows it would return an error code, and optionally
output to the error stream.

[.chg]
_NOTE 2_:
It is up to a program that interacts with an application implementing
introspection to determine what option syntax variation the application
supports. One method to accomplish that is to execute the application with one
of the two syntax styles and use the error indication to conclude which syntax
works. Another is to have a priori knowledge of which syntax variation works.

[#intspct-opt-info,reftext=intspct.opt.info]
===== Information Option [.right]#[<<intspct-opt-info>>]#

This option shall be supported.

[.chg]
`__std-info-opt__`::
Outputs the version information of the capabilities supported by the
application.
The option is specified as `--std-info` or `-std-info`.
The option can be specified zero or one time.
The application shall support the option for _minimum level_ (<<intspct-min>>)
functionality.

[#intspct-opt-out,reftext=intspct.opt.out]
===== Information Output Option [.right]#[<<intspct-opt-out>>]#

This option shall be supported.

[.chg]
`__std-info-out-opt__ __file__`::
The pathname of a file to output the information to.
The option is specified as `--std-info-out=__file__` or `-std-info-out:__file__`.
If _file_ is '`-`', the standard output shall be used.
The application shall support the option for _minimum level_ (<<intspct-min>>)
functionality.
Not specifying this option while specifying the `__std-info-opt__` option
(<<intspct-opt-info>>) shall be equivalent to also specifying a
`__std-info-out-opt__ __file__` option where _file_ is '`-`'.

[#intspct-opt-decl,reftext=intspct.opt.decl]
===== Declaration Option [.right]#[<<intspct-opt-decl>>]#

This option should be supported.

[.chg]
`__std-info-opt__ __declaration__`::
Declares the required capability version of the application.
The option is specified as `--std-info=__declaration__`
or `-std-info:__declaration__`.
The option can be specified any number of times.
The application shall support the option for _full level_ (<<intspct-full>>)
functionality.

[#intspct-output,reftext=intspct.output]
===== Output [.right]#[<<intspct-output>>]#

An application shall output a valid JSON text file that conforms to the
introspection schema (<<intspct-schema>>) to the file specified in the options
(<<intspct-opt-out>>).

[#intspct-file,reftext=intspct.file]
[.chg]
===== Files [.right]#[<<intspct-file>>]#

An application can provide an _introspection file_ that contains valid JSON
that conforms to the introspection schema (<<intspct-schema>>).

An _introspection file_ shall contain the same information as that produced from
the `__std-info-opt__` information option (<<intspct-opt-info>>).

An _introspection file_ shall be named the same as the application with any
filename extension replaced with the `stdinfo` filename extension.
It is implementation defined how the filename of the _introspection file_
replaces the application filename extension with the new `stdinfo` filename
extension.

_NOTE 1_:
For Windows, POSIX, and other platforms replacing the filename extension would
remove any filename bytes after the last period (U+002E FULL STOP) and append
the `stdinfo` sequence of bytes.

An _introspection file_ shall either have the same parent directory as the
application, have an implementation defined parent directory that is relative
to the parent directory of the application, or have an implementation defined
parent directory.

[#intspct-schema,reftext=intspct.schema]
===== Schema [.right]#[<<intspct-schema>>]#

An introspection JSON text file shall contain one introspection JSON object
(<<intspct-schema-obj>>).

[#intspct-schema-obj,reftext=intspct.schema.obj]
====== Introspection Object [.right]#[<<intspct-schema-obj>>]#

The _introspection object_ is the root JSON object of the introspection JSON
text.

An _introspection object_ can have the following fields.

[#intspct-fld-schema,reftext=intspct.schema.schema]
====== JSON Schema Field [.right]#[<<intspct-fld-schema>>]#

_Name_: `$schema` +
_Type_: `string` +
_Value_:
  The value shall be a reference to a JSON Schema specification. +
_Description_:
  An _introspection object_ can contain this field.
  If an _introspection object_ does not contain this field the value shall be a
  reference to the JSON Schema corresponding to the current edition of this
  standard.

[#intspct-fld-cap,reftext=intspct.schema.cap]
====== Capability Field [.right]#[<<intspct-fld-cap>>]#

_Name_: _capability-identifier_ (<<intspct-cap>>) +
_Type_: `string` or `array` +
_Value_ (for `string`):
  The value shall be a _version-number_ for _minimum level_ functionality.
  Or the value shall be a _version-range_ for _full level_ functionality. +
_Value_ (for `array`):
  The value can be a JSON array for _full level_ functionality.
  If the value is a JSON array the items in the array shall be a
  _version-number_ or _version-range_.
_Description_:
  An _introspection object_ can contain this field one or more times.
  When the field appears more than one time the name of the fields shall be
  unique within the _introspection object_.

[#intspct-cap,reftext=intspct.cap]
===== Capabilities [.right]#[<<intspct-cap>>]#

_capability-identifier_: ::
  _name_ _scope-designator_ _name_ _sub-capability-identifier~opt~_
_sub-capability-identifier_: ::
  _scope-designator_ _name_ _sub-capability-identifier~opt~_
_name_: ::
  one or more of: +
  U+0061 .. U+007A LATIN SMALL LETTER A .. Z +
  U+0030 .. u+0039 DIGIT ZERO .. NINE +
  U+005F LOW LINE
_scope-designator_: ::
  U+003A COLON

A _capability-identifier_ is composed of two or more _scope-designator_
delimited _name_ parts.

The _name_ `std` in a _capability-identifier_ is reserved for capabilities
defined in this standard.

Applications can specify vendor designated _name_ parts defined outside of this
standard.

[#intspct-vers,reftext=intspct.vers]
===== Versions [.right]#[<<intspct-vers>>]#

A version shall be either a single version number (<<intspct-vers-num>>) or a
version range (<<intspct-vers-range>>).

A single version number shall be equivalent to the inclusive version range
spanning solely that single version number.

_NOTE 1_:
That is the version number `i.j.k` is equivalent to version range
`[i.j.k,i.j.k]`.

[.chg]
[#intspct-vers-num,reftext=intspct.vers.num]
====== Version Number [.right]#[<<intspct-vers-num>>]#

A _version number_ shall conform to the SemVer `<version core>` syntax.

A version number can be truncated to only `<major>` or `<major>.<minor>` syntax.

A version number composed of only `<major>` is equivalent to `<major>.0.0`.

A version number composed of only `<major>.<minor>` is equivalent to
`<major>.<minor>.0`.

Version numbers define a total ordering where version number _a_ is ordered
before a version number _b_ when _a_ has a lower SemVer precedence than _b_.

[#intspct-vers-range,reftext=intspct.vers.range]
====== Version Range [.right]#[<<intspct-vers-range>>]#

_version-range_: ::
  _version-range-min-bracket_
  _version-min-number_ _version-range-max-part_~opt~ _version-range-max-bracket_
_version-range-max-part_: ::
  U+002C COMMA _version-max-number_
_version-min-number_: ::
  _version-number_
_version-max-number_: ::
  _version-number_
_version-range-min-bracket_::
  one of: U+005B LEFT SQUARE BRACKET U+0028 LEFT PARENTHESIS
_version-range-max-bracket_::
  one of: U+005D RIGHT SQUARE BRACKET U+0029 RIGHT PARENTHESIS

A version range is composed of either one version number bracketed,
or two version numbers separated by a U+002C COMMA and bracketed.

_EXAMPLE 1_:
A version range with a single version number "`[1.0.0]`".

_EXAMPLE 2_:
A version range with two version numbers "`[1.0.0,2.0.0]`".

A version range _a_ that is `[_i_,_j_]` makes _i_ and _j_ inclusive version
range numbers, defining a Mathematics closed interval.

A version range _a_ that is `(_i_,_j_)` makes _i_ and _j_ exclusive version
range numbers, defining a Mathematics open interval.

A version range _a_ that is `(_i_,_j_]` makes _i_ an exclusive version number
and _j_ an inclusive version number, defining a Mathematics half-open
interval.

A version range _a_ that is `[_i_,_j_)` makes _j_ an exclusive version number
and _i_ an inclusive version number, defining a Mathematics half-open
interval.

A version range with a single inclusive version number _x_ is equivalent to the
version range `[_x_,_x_]`.

A version range with a single exclusive version number _x_ is invalid.

An exclusive version number _x_ does not include the version number _x_ when
compared to another version number _y_.

A version range _a_ with version numbers _i_ and _j_ when compared to a version
range _b_ with version number _m_ and _n_ will result in an empty version range
when: _j_ < _m_ or _n_ < _i_.f

Otherwise if _i_ or _m_ are inclusive version numbers and if _j_ or _n_ are
inclusive version numbers the resulting range when _a_ is compare to _b_ is
the inclusive version numbers "lesser of _i_ and _m_" and
"lesser of _j_ and _n_".

Otherwise if _i_ or _m_ are inclusive version numbers and if _j_ or _n_ are
inclusive version numbers the resulting range when _a_ is compare to _b_ is
the inclusive version number "lesser of _i_ and _m_" and the exclusive version
number "lesser of _j_ and _n_".

Otherwise if _j_ or _n_ are inclusive version numbers the resulting range when
_a_ is compared to _b_ is the exclusive version number "lesser of _i_ and _m_"
and the inclusive version number "lesser of _j_ and _n_".

Otherwise the resulting range when _a_ is compared to _b_ is the exclusive
version numbers "lesser of _i_ and _m_" and "lesser of _j_ and _n_".

[#intspct-min,reftext=intspct.min]
===== Minimum Level [.right]#[<<intspct-min>>]#

An application that supports the _minimum level_ functionality indicates it by
specifying a single version (<<intspct-vers-single>>) as the value of the
`std:info` capability (<<intspct-cap>>).

_EXAMPLE 1_: +
`{ "std:info": "1.0.0" }`

[#intspct-full,reftext=intspct.full]
===== Full Level [.right]#[<<intspct-full>>]#

An application can support the _full level_ functionality as defined in this
section. An application that reports supporting the _full level_ functionality
shall support all of the functionality in this section.

An application that supports the _full level_ functionality indicates it by
specifying a version range (<<intspct-vers-single>>) or an array of version
range items as the value of the `std:info` capability (<<intspct-cap>>).

_EXAMPLE 1_: +
`{ "std:info": "[1.0.0]" }`

An application that responds with an array of version range items as the value
of a capability field shall support the union of the range items indicated.

[#intspct-info,reftext=intspct.info]
===== Introspection Information [.right]#[<<intspct-info>>]#

An application shall output an introspection schema (<<intspct-schema>>) that
contains one capability field for each capability that the application supports
when given the `--std-info` option (<<intspct-opt-info>>).

An application shall indicate the single version (<<intspct-vers-num>>) or
version range (<<intspct-vers-range>>) of each capability it supports as the
value of the capability field.

[#intspct-dcl,reftext=intspct.dcl]
===== Introspection Declaration [.right]#[<<intspct-dcl>>]#

[.chg]
An application that supports the _full level_ functionality when given one or
more `_std-info-opt_ _declaration_` options shall conform its functionality to
the indicated edition of this standard in the given _declaration_
_version-number_ for the given capability.

_declaration_: ::
  _capability-identifier_ U+003D EQUALS SIGN _version-number_

[.chg]
An application, when not given a `_std-info-opt_ _declaration_` option for a
capability it supports, should conform its functionality to the most recent
version of the standard it supports for that capability.

An application, when given a capability declaration option and the given
version is outside of the version range that the application supports, should
indicate an error.

=== JSON Schema

Insert clause before _Bibliography_.

[.ins.text-justify]
[#intspct-json-schema,reftext=intsjschm]
==== Annex A (informative) Tool Introspection _JSON Schema_ [.right]#[<<intspct-json-schema>>]#

[#intspct-json-schema-general,reftext=intsjschm.general]
===== General [.right]#[<<intspct-json-schema-general>>]#

This Annex defines the introspection capability schema
(<<intspct-schema>>) in terms of a _JSON Schema_. A _JSON Schema_ refers to the
IETF RFC draft "JSON Schema: A Media Type for Describing JSON Documents" as
specified in https://json-schema.org/draft/2020-12/json-schema-core.html.

This JSON Schema can be referenced as the `$schema` field with URI value of
`"https://raw.githubusercontent.com/cplusplus/ecosystem-is/release/schema/std_info-1.0.0.json"`.

[#intspct-json-schema-spec,reftext=intsjschm.spec]
===== JSON Schema Specification [.right]#[<<intspct-json-schema-spec>>]#

[source,json]
----
include::std_info-1.0.0.json[]
----

== Examples

=== Portable Command Lines

Assuming that the Ecosystem IS specifies a common set of portable command line
compiler options an interaction between a build system (or user at a command
prompt) and a compiler could look like:

Build systems asks the compiler for supported capabilities:

[,shell]
----
$ c++ --std-info
{ "std:info": "[1]", "std:cli:c++", "[1]" }
----

NOTE: The build system would likely want to cache that information as it's
likely to be static for the release of the compiler.

The build system could then declare and use any such portable compiler options:

[,shell]
----
$ c++ --std-info=std:cli:c++=1 -std=c++26 -I /home/user/boost -o myapp main.cpp
----

The interaction when the compiler tool only supports the minimum level would be:

[,shell]
----
$ c++ --std-info
{ "std:info": "1", "std:cli:c++", "1" }
$ c++ -std=c++26 -I /home/user/boost -o myapp main.cpp
----

This example predicts that it might be useful outside of the {CPP} ecosystem by
using `std:cli:c++` to indicate a {CPP} specific command line. It could be
that Fortran uses a different, but possibly overlapping CLI:

[,shell]
----
$ gcc --std-info
{ "std:info": "1", "std:cli:c++", "1", "gcc:cli:fortran", "1" }
$ gcc -std=f2018 -o myapp main.fpp
----

== Acknowledgements

Thanks to Jens Maurer for some initial wording review.

Thanks to Charles-Henri Gros for feedback on version ranges.

Thanks to Fangrui Song for feedback on command line option syntax and assessment
of changes to clang and for the applications that use `getlong_opt`.

Thanks to Jason Merrill and Fangrui Song for assessment of changes to GCC.

Thanks to Olga Arkhipova for suggesting the use of files as the user interface.

== License

This work is licensed under the Creative Commons Attribution 4.0 International
License. To view a copy of this license, visit
http://creativecommons.org/licenses/by/4.0/ or send a letter to Creative
Commons, PO Box 1866, Mountain View, CA 94042, USA.
